1. Результат командной работы
Наша версия приложения rslang - это SPA, состоящий из из следующих составляющих (_по ходу рассказа кликаем по соответствующему разделу_):
 - главное навигационное меню сверху: 
    - sticky, 
    - содержит ссылки на основные рабочие экраны: словарь, мини-игры, статистика + возврат на главную страницу
    - отсюда же происходит аутентификация/логаут
 - главная страница (не останавливаемся здесь, ровно по ТЗ без особенностей)
 - словарь:
    - слева: меню выбора главы учебника (включая 7-й "скрытый" раздел), оформлено разными цветами для удобства навигации
    - сверху: навигация по страницам выбранной главы учебника (пагинация), со стилизацией полностью изученных страниц
    - также сверху: ссылки на мини-игры (неактивны на полностью изученных страницах)
    - на пересечении - карточки слов с кнопками проигрывания аудио, всплывающими примерами и кнопками для добавления/снятия признаков "Сложное" или "Изученное"
 - мини-игры:
    - реализованы игры Аудио-вызов и Спринт из Lingualeo
    - подбор слов для игры реализован через привязку к query string в url: если параметр group (глава учебника) не задан, игра просит выбрать уровень сложности; в остальных случаях сразу начинается раунд со словами той главы/страницы, которая указана в url.
    - реализован основной геймплей, включая базовое управление с клавиатуры
    - релизована страница результатов игры (выводится как по окончании раунда, так и при досрочном закрытии игры)
  - статистика:
    - реализована как обязательная краткосрочная статистика (в виде дашборда за сегодня), так и дополнительная долгосрочная статистика (в виде графиков по дням)
  - аутентификация - для анонимного пользователя:
    - подкидывается логин-форма вместо статистики
    - скрываются кнопки Сложное/Изученное в карточках слов в словаре
    - НЕ сохраняется статистика мини-игр
    - дополнительно реализован функционал изменения логина/пароля

2. Организация командной работы:
_(Открыть RACI-матрицу и рассказывать на ней)_
https://docs.google.com/spreadsheets/d/1x6BkesQniHLXf7drUa2OcLkPFXd0dOGE90uV63dMOxg/edit#gid=0
 - Ян:
    - тимлид: организовывал командную работу, нарезал задачи, принимал участие в код-ревью, принимал PRы, оформлял итоговый PR и самооценку
    - общепроектные вопросы: настраивал первоначальное рабочее окружение (CRA, подключал основные библиотеки), осуществлял периодический деплой на netlify
    - работа с бэкендом: разворачивал БД Mongo Atlas, деплоил копию бэкенда на heroku, вносил изменения в некоторые схемы mongoose и эндпойнты (userWords и statistics)
    - по самому приложению: отвечал за реализацию главного навигационного меню (включая настройку маршрутизации на клиенте), а также обеих мини-игр (включая сохранение игровой статистики)
 - Влад:
    - сверстал часть главной страницы
    - реализовал функционал карточки слова (включая обертки для API, управление Сложными/Изученными словами и статистику по данному слову)
    - реализовал функционал словаря (включая пагинацию разделов и страниц, а также привязку к url)
 - Сергей:
    - сверстал часть главной страницы и футер
    - реализовал функционал аутентификации (включая формы sign-up/in, обертки для API, разворачивание redux store и authSlice)
    - реализовал раздел со статистикой (дашборды для краткосрочной и графики для долгосрочной статистики)
 - Александр (ментор):
    - мониторил прогресс работ, участвовал в код-ревью и приемке PRов
    - предоставлял консультации по best practices и помощь в решении сложных задач

В качестве инструментария для командной работы выбрали Github Projects:
 - был заведен проект на GH и в самом начале проекта создано большинство тасков (issues)
 - работа велась недельными спринтами (iterations), наполнение спринтов поначалу происходило согласно предполагаемому плану работ по неделям, далее в следующие спринты могли перетаскиваться незаконченные карточки с предыдущего спринта
 - для канбан-доски были заведены статусы: backlog (=что нужно сделать за спринт), assigned (=назначен ответственный), in progress (=работа началась), in review (=на код-ревью или в процессе исправления замечаний), done (=PR залит на develop)
 - работу вели согласно рекомендациям: разработка фич/багфикс в отдельных ветках -> PR в develop -> код-ревью и тестирование -> мердж в ветку develop
 - практически вся коммуникация происходила асинхронно через Github и чат в discord'е, живые созвоны производили раз-два в неделю, в дейликах как таковых не было потребности
 - организационные сложности:
    - никто раньше в GH не работал, первое время были косяки в оформлении PRов (много изменений в 1 PR, не подтянуты issues, milestones, не удалена ветка разработки после мерджа, отсутствие ответов на комментарии в ходе код-ревью и т.п.)  
      _решение: со временем просто привыкли к работе в GH_
    - неравномерность нагрузки (нормальный темп в течение первых 2-х спринтов, авральный - на 3-м спринте)  
      _причина: отложили на 3-й спринт тему со статистикой, сложными/изученными словами, но эти фичи оказались сложнее ожидаемого_
    - на 3-м спринте ввиду большой нагрузки на тимлида (и ревью, и собственные таски) на некоторое время перестали поддерживать актуальность канбан-доски  
      _решение: нет, порядок в карточках навели только после дедлайна_
    - на бесплатном плане в GH не получилось настроить защиту ветки main - было пару эпизодов, когда PRы делались не в develop, а прямо в main  
      _решение: чистили ветку main от лишних комментов (благо, так можно было делать, поскольку на нее не ссылались нигде в работе)_  

3. Особенности технической реализации проекта и его репозиторий:
 - _(прокомментировать зависимости проекта в readme.md: проект на React/Redux/React Router/Bootstrap+MUI и т.п.)_
 - _(показать историю коммитов быстро)_
 - _(показать, например, PR #87: https://github.com/malashonock/rslang/pull/87)_
 - подход к код-ревью: ревьюер оставляет комментарии - ответственный отвечает на каждый - ревьюер или тимлид резолвают комментарии и жмут approve/request changes; approve тимлида обязателен перед мерджем PRа, approve ментора - обязателен, если ментор делал ревью
 - технические сложности:
    - основная проблема: новизна практически всех используемых технологий (react, redux, router) для членов команды
    - были трудности с правильным редиректом после регистрации/аутентификации пользователя (_Сергей комментирует при необходимости_)
    - в мини-играх было сложно уложить всю логику игры (выбор уровня, подготовка слов, цепочка ходов, выход из игры, вывод результатов) на react
    - в мини-играх была проблема с двойным рендером первого хода (выглядело как замена слов в первом ходе через секунды после старта раунда): частично причина была в особенностях development mode в react (двойной рендер), частично - были ошибки в логике игр
    - в словаре было проблематично реализовать стилизацию полностью изученных глав (_Влад комментирует при необходимости_): решили путем разработки нового GET-эндпоинта на бэкенде, в основе которого "трехэтажный" MQL-запрос + хранением состояния в redux store и подпиской на него всех задействованных компонентов
    - реализация эндпоинтов, связанных со статистикой: users/words и users/statistics - показалась недостаточно удобной (поле optional не хотелось использовать): доработали соответствующие эндпоинты, добавив все необходимые для сбора статистики параметры в схему mongoose










